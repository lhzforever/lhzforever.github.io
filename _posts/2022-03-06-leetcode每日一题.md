---
layout: article
title: leetcode每日一题
tags: java
show_subscribe: false
show_edit_on_github: false
license: false
---

<!--more-->

## 算法苦手




### 零矩阵

**来源：**	<https://leetcode-cn.com/problems/zero-matrix-lcci/>	

**想法：**

​	遍历矩阵，使用两个数组来记录矩阵中哪些行和列需要变为0，然后根据第一遍遍历完矩阵得出的数组，第二遍遍历矩阵，将需要改为0的元素修改。

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        boolean[] rows = new boolean[m];
        boolean[] cols = new boolean[n];
        for (int i = 0 ; i < m ; i++) {
            for (int j = 0 ; j < n ; j++) {
                if (matrix[i][j] == 0) {
                    rows[i] = true;
                    cols[j] = true;
                }
            }
        }
        for (int i = 0 ; i < m ; i++) {
            for (int j = 0 ; j < n ; j++) {
                if (rows[i] || cols[j]) {
                    matrix[i][j] = 0;
                }
            }
        }
    }
}
```

**时间复杂度：** **O(mn)**

**空间复杂度：** **O(m + n)**

**优化：**

​	可将矩阵的第一行和第一列作为记录需要修改为0的行和列的数据，额外使用两个标记变量来记录第一行和第一列是否需要修改为0即可。

**时间复杂度：** **O(mn)**

**空间复杂度：** **O(1)**





### 字符串轮转

**来源：**	<https://leetcode-cn.com/problems/string-rotation-lcci/>	

**想法：**

​	遍历字符串S1，以当前字符为分界点，判断S1分成的前后两个字符串与S2分成的两个字符串是否相同。

```java
class Solution {
    public boolean isFlipedString(String s1, String s2) {
        if (s1.equals("") && s2.equals("")) return true;
        if (s1.length() != s2.length()) return false;
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();
        int n = 0;
        while(true) {
            while (n < c1.length && c1[n] != c2[0]) n++;
            if (n == c1.length) return false;
            else {
                int m = 0;
                while (m + n < c1.length && c1[m + n] == c2[m]) m++;
                if (m + n  == c1.length) {
                    int k = 0;
                int tmp = c2.length - n;
                    while (tmp + k < c2.length && c1[k] == c2[k + tmp]) k++;
                    if (k + tmp == c2.length) return true;
                    else n++;
                }else n++;
            }
        }
    }
}
```

**时间复杂度：** **O(n²)**

**空间复杂度：** **O(n)**

**优化：**

​	若将 $S_1$ 分成的两个子串视为 $L$ 和 $R$ , 可并凑字符串 $S_2 + S_2$ , 所得到的字符串即为 $L +  R + L + R = L + S_1 + R$ ，则只需判断 $S_1$ 是否是 $S_2 + S_2$ 的子串即可。

**时间复杂度：** **O(n)** **(KMP)** 

**空间复杂度：** **O(n)**



### 移除重复节点

**来源：**	<https://leetcode-cn.com/problems/remove-duplicate-node-lcci/>	

**想法：**

​	遍历链表途中，用哈希集合存储该节点的值是否出现过，出现过将节点移出即可。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeDuplicateNodes(ListNode head) {
        HashSet<Integer> nums = new HashSet<>();
        if (head == null) return head;
        nums.add(head.val);
        ListNode pos = head;
        while (pos.next != null) {
            ListNode cur = pos.next;
            if (nums.add(cur.val)) {
                pos = pos.next;
            } else {
                pos.next = pos.next.next;
            }
        }
        pos.next = null;
        return head;
    }
}
```

**时间复杂度：** **O(n)**

**空间复杂度：** **O(n)**



### 返回倒数第k个节点

**来源：**	<https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/>	

**想法：**

​	使用两个指针，保持两个指针相隔的节点数为k，第一个指针到达链表尾部时，第二个指针即为倒数第k个节点。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int kthToLast(ListNode head, int k) {
        ListNode p1 = head;
        ListNode p2 = head;
        int cnt = 0;
        while (cnt < k) {
            p1 = p1.next;
            cnt++;
        }
        while (p1 != null) {
            p1 = p1.next;
            p2 = p2.next;
        }
        return p2.val;
    }
}
```

**时间复杂度：** **O(n)**

**空间复杂度：** **O(1)**

