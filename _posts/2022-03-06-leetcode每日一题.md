---
layout: article
title: leetcode每日一题
tags: java
show_subscribe: false
show_edit_on_github: false
license: false
---

<!--more-->

# 算法苦手



## 零矩阵

**来源：**	<https://leetcode-cn.com/problems/zero-matrix-lcci/>	

**想法：**

​	遍历矩阵，使用两个数组来记录矩阵中哪些行和列需要变为0，然后根据第一遍遍历完矩阵得出的数组，第二遍遍历矩阵，将需要改为0的元素修改。

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        boolean[] rows = new boolean[m];
        boolean[] cols = new boolean[n];
        for (int i = 0 ; i < m ; i++) {
            for (int j = 0 ; j < n ; j++) {
                if (matrix[i][j] == 0) {
                    rows[i] = true;
                    cols[j] = true;
                }
            }
        }
        for (int i = 0 ; i < m ; i++) {
            for (int j = 0 ; j < n ; j++) {
                if (rows[i] || cols[j]) {
                    matrix[i][j] = 0;
                }
            }
        }
    }
}
```

**时间复杂度：** **O(mn)**

**空间复杂度：** **O(m + n)**

**优化：**

​	可将矩阵的第一行和第一列作为记录需要修改为0的行和列的数据，额外使用两个标记变量来记录第一行和第一列是否需要修改为0即可。

**时间复杂度：** **O(mn)**

**空间复杂度：** **O(1)**



## 字符串轮转

**来源：**	<https://leetcode-cn.com/problems/string-rotation-lcci/>	

**想法：**

​	遍历字符串S1，以当前字符为分界点，判断S1分成的前后两个字符串与S2分成的两个字符串是否相同。

```java
class Solution {
    public boolean isFlipedString(String s1, String s2) {
        if (s1.equals("") && s2.equals("")) return true;
        if (s1.length() != s2.length()) return false;
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();
        int n = 0;
        while(true) {
            while (n < c1.length && c1[n] != c2[0]) n++;
            if (n == c1.length) return false;
            else {
                int m = 0;
                while (m + n < c1.length && c1[m + n] == c2[m]) m++;
                if (m + n  == c1.length) {
                    int k = 0;
                int tmp = c2.length - n;
                    while (tmp + k < c2.length && c1[k] == c2[k + tmp]) k++;
                    if (k + tmp == c2.length) return true;
                    else n++;
                }else n++;
            }
        }
    }
}
```

**时间复杂度：** **O(n²)**

**空间复杂度：** **O(n)**

**优化：**

​	若将 $S_1$ 分成的两个子串视为 $L$ 和 $R$ , 可并凑字符串 $S_2 + S_2$ , 所得到的字符串即为 $L +  R + L + R = L + S_1 + R$ ，则只需判断 $S_1$ 是否是 $S_2 + S_2$ 的子串即可。

**时间复杂度：** **O(n)** **(KMP)** 

**空间复杂度：** **O(n)**



