---
layout: article
title: 算法练习part2
tags: 算法
show_subscribe: false
show_edit_on_github: false
license: false
---

<!--more-->

## 算法苦手



### 二叉树剪枝

**来源：**	https://leetcode.cn/problems/pOCWxh/

**想法：**

​	后序遍历

```java
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* pruneTree(TreeNode* root) {
        if (root == nullptr) {
            return nullptr;
        }
        TreeNode* left = pruneTree(root->left);
        TreeNode* right = pruneTree(root->right);
        if (root->val == 0 && left == nullptr && right == nullptr) {
            return nullptr;
        }
        root->left = left;
        root->right = right;
        return root;
    }
};
```



**时间复杂度：** **O(n)** 

**空间复杂度：** **O(n) **



#### 从根节点到叶节点的路径数字之和

**来源：**	https://leetcode.cn/problems/3Etpl5/

**想法：**

​	遍历树即可

```java
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int sum = 0;
    void run(TreeNode* node, int val) {
        if (node->left != nullptr) run(node->left,val * 10 + node->val);
        if (node->right != nullptr) run(node->right,val * 10 + node->val);
        if (node->left == nullptr && node->right == nullptr) sum += val * 10 + node->val;
    }
    int sumNumbers(TreeNode* root) {
        run(root,0);
        return sum;
    }
};
```



**时间复杂度：** **O(n)** 

**空间复杂度：** **O(n) **





#### 向下的路径节点之和

**来源：**	https://leetcode.cn/problems/6eUYwP/

**想法：**

​	遍历树的同时维护节点路径

```java
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int res = 0;
    int target;
    void preorder(TreeNode* node, vector<int>& road) {
        road.push_back(node->val);
        if (node->left != nullptr) preorder(node->left,road);
        if (node->right != nullptr) preorder(node->right,road);
        int tmp = 0;
        for (int i = road.size() - 1 ; i >= 0 ; i--) {
            tmp += road[i];
            if (tmp == target) {
                res++;
            }
        }
        road.pop_back();
    }
    int pathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) return 0;
        vector<int> v;
        target = targetSum;
        preorder(root,v);
        return res;
    }
};
```



**时间复杂度：** **O(n²)** 

**空间复杂度：** **O(n) **





#### 展平二叉搜索树

**来源：**	https://leetcode.cn/problems/NYBBNL/

**想法：**

​	前序遍历

```java
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode *res = nullptr;
    TreeNode *head;
    void midorder(TreeNode *node) {
        if (node->left != nullptr) midorder(node->left);
        if (res == nullptr) {
            res = new TreeNode(node->val);
            head = res;
        }
        else {
            res->right = new TreeNode(node->val);
            res = res->right;
        }
        if (node->right != nullptr) midorder(node->right);
    }
    TreeNode* increasingBST(TreeNode* root) {
        midorder(root);
        return head;
    }
};
```



**时间复杂度：** **O(n²)** 

**空间复杂度：** **O(n) **



#### 二叉搜索树中的中序后继

**来源：**	https://leetcode.cn/problems/P5rCT8/

**想法：**

​	中序遍历

```java
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
        stack<TreeNode*> s;
        bool sign = false;
        while (root != nullptr || !s.empty()) {
            while (root != nullptr) {
                s.push(root);
                root = root->left;
            }
            root = s.top();
            s.pop();
            if (sign) break;
            if (root == p) sign = true;
            root = root->right;
        }
        return root;
    }
};
```



**时间复杂度：** **O(n)** 

**空间复杂度：** **O(n) **



#### 所有大于等于节点的值之和

**来源：**	https://leetcode.cn/problems/w6cpku/

**想法：**

​	中序遍历

```java
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* convertBST(TreeNode* root) {
        TreeNode *tmp1 = root, *tmp2 = root;
        stack<TreeNode*> s;
        int sum = 0;
        int prev = 0;
        while (tmp1 != nullptr || !s.empty()) {
            while (tmp1 != nullptr) {
                s.push(tmp1);
                tmp1 = tmp1->left;
            }
            tmp1 = s.top();
            s.pop();
            sum += tmp1->val;
            tmp1 = tmp1->right;
        }
        while (tmp2 != nullptr || !s.empty()) {
            while (tmp2 != nullptr) {
                s.push(tmp2);
                tmp2 = tmp2->left;
            }
            tmp2 = s.top();
            s.pop();
            int tmp = tmp2->val;
            tmp2->val = sum - prev;
            prev += tmp;
            tmp2 = tmp2->right;
        }
        return root;
    }
};
```



**时间复杂度：** **O(n)** 

**空间复杂度：** **O(n) **





#### 二叉搜索树中两个节点之和

**来源：**	https://leetcode.cn/problems/opLdQZ/

**想法：**

​	中序遍历,用哈希表存储已经遍历到的节点的值，然后每遍历一个节点，只需要找哈希表里是否存在 k - val 即可

```java
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool findTarget(TreeNode* root, int k) {
        stack<TreeNode*> s;
        set<int> base;
        while (root != nullptr || !s.empty()) {
            while (root != nullptr) {
                s.push(root);
                root = root->left;
            }
            root = s.top();
            s.pop();
            if (base.find(k - root->val) != base.end()) return true;
            base.insert(root->val);
            root = root->right;
        }
        return false;
    }
};
```



**时间复杂度：** **O(n)** 

**空间复杂度：** **O(n) **





#### 日程表

**来源：**	https://leetcode.cn/problems/opLdQZ/

**想法：**

​	线段树，left存储日程在节点之前的，right存储日程在节点之后的

```java
class MyCalendar {
public:
    struct TreeNode{
        TreeNode* left;
        TreeNode* right;
        int start;
        int end;
        TreeNode(int x, int y) : start(x), end(y), left(nullptr), right(nullptr) {}
    };
    TreeNode *root = nullptr;
    MyCalendar() {

    }
    
    bool book(int start, int end) {
        if (root == nullptr) {
            root = new TreeNode(start,end);
            return true;
        }
        TreeNode *tmp = root;
        while (tmp != nullptr) {
            if (end <= tmp->start) {
                if (tmp->left == nullptr) {
                    tmp->left = new TreeNode(start,end);
                    return true;
                }
                tmp = tmp->left;
            }else if (start >= tmp->end){
                if (tmp->right == nullptr) {
                    tmp->right = new TreeNode(start,end);
                    return true;
                }
                tmp = tmp->right;
            }else return false;
        }
        return true;
    }
};
```



**时间复杂度：** **O(logn)** 

**空间复杂度：** **O(n) **





#### 实现前缀树

**来源：**	https://leetcode.cn/problems/QC3q1f/

**想法：**

​	字典树

```java
class Trie {
public:
    vector<Trie*> children;
    bool isEnd;
    /** Initialize your data structure here. */
    Trie() : children(26), isEnd(false){}
    
    /** Inserts a word into the trie. */
    void insert(string word) {
        Trie* node = this;
        for (char c : word) {
            if (node->children[c - 'a'] == nullptr) {
                node->children[c - 'a'] = new Trie();
            }
            node = node->children[c - 'a'];
        }
        node->isEnd = true;
    }
    
    /** Returns if the word is in the trie. */
    bool search(string word) {
        Trie* node = this;
        for (char c : word) {
            if (node->children[c - 'a'] == nullptr) {
                return false;
            }
            node = node->children[c - 'a'];
        }
        return node != nullptr && node->isEnd;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        Trie* node = this;
        for (char c : prefix) {
            if (node->children[c - 'a'] == nullptr) {
                return false;
            }
            node = node->children[c - 'a'];
        }
        return node != nullptr;
    }
};
```



**时间复杂度：** **初始化为 O(1)，其余操作为 O(|S|)，其中 |S| 是每次插入或查询的字符串的长度。**

**空间复杂度：** ***O*(∣*T*∣⋅Σ)，其中 |T| 为所有插入字符串的长度之和，Σ 为字符集的大小，本题 Σ=26。**



#### 替换单词

**来源：**	https://leetcode.cn/problems/QC3q1f/

**想法：**

​	哈希表

```java
class Solution {
public:
    string replaceWords(vector<string>& dictionary, string sentence) {
        string res = "";
        string temp = sentence + " ";
        vector<string> strs;
        size_t pos = temp.find(" ");
        while (pos != temp.npos) {
            string tmp = temp.substr(0, pos);
            strs.push_back(tmp);
            temp = temp.substr(pos + 1, temp.size());
            pos = temp.find(" ");
        }
        set<string> roots;
        for (string i : dictionary) {
            roots.insert(i);
        }
        for (string i : strs) {
            bool flag = false;
            for (int j = 1 ; j < i.length() ; j++) {
                string tmp = i.substr(0,j);
                if (roots.find(tmp) != roots.end()) {
                    res.append(tmp).append(" ");
                    flag = true;
                    break;
                }
            }
            if (!flag) res.append(i).append(" ");
        }
        res = res.substr(0,res.size() - 1);
        return res;
    }
};
```



**时间复杂度：** **O(n)** 

**空间复杂度：** **O(n)** 



#### 神奇的字典

**来源：**	https://leetcode.cn/problems/US1pGT/

**想法：**

​	前缀树，遍历字符串，对每个字符存在25种替换，如果遍历其后面的子串可以遍历到尾，就返回true，否则返回false。

```java
class MagicDictionary {
public:
    vector<MagicDictionary*> children;
    bool isEnd;
    /** Initialize your data structure here. */
    MagicDictionary() : children(26), isEnd(false){}
    
    void buildDict(vector<string> dictionary) {
        for (string str : dictionary) {
            MagicDictionary* node = this;
            for (char c : str) {
                if (node->children[c - 'a'] == nullptr) {
                    node->children[c - 'a'] = new MagicDictionary();
                }
                node = node->children[c - 'a'];
            }
            node->isEnd = true;
        }
    }
    
    bool search(string searchWord) {
        MagicDictionary* node = this;
        int n = searchWord.length();
        for (int i = 0 ; i < n ; i++) {
            int num = searchWord[i] - 'a';

            for (int x = 0 ; x < 26 ; x++) {
                if (x == num || node->children[x] == nullptr) continue;
                string tmp_str = searchWord.substr(i + 1);
                auto tmp_node = node->children[x];
                bool flag = true;
                for (int j = 0 ; j < tmp_str.length() ; j++) {
                    if (tmp_node->children[tmp_str[j] - 'a'] == nullptr) {
                        flag = false;
                        break;
                    }
                    tmp_node = tmp_node->children[tmp_str[j] - 'a'];
                }
                if (flag) flag = tmp_node->isEnd;
                if (flag) return true;
            }
            if (node->children[num] == nullptr) return false;
            node = node->children[num];
        }
        return false;
    }
};
```



**时间复杂度：** **O(|S|⋅ Σ)，其中 |S| 是每次插入或查询的字符串的长度, Σ 为字符集的大小，本题 Σ=26。** 

**空间复杂度：** **O(|T|⋅Σ)，其中 |T| 为所有插入字符串的长度之和，Σ 为字符集的大小，本题 Σ=26。**
