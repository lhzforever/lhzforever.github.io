---
layout: article
title: 算法练习part2
tags: 算法
show_subscribe: false
show_edit_on_github: false
license: false
---

<!--more-->

## 算法苦手



### 二叉树剪枝

**来源：**	https://leetcode.cn/problems/pOCWxh/

**想法：**

​	后序遍历

```java
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* pruneTree(TreeNode* root) {
        if (root == nullptr) {
            return nullptr;
        }
        TreeNode* left = pruneTree(root->left);
        TreeNode* right = pruneTree(root->right);
        if (root->val == 0 && left == nullptr && right == nullptr) {
            return nullptr;
        }
        root->left = left;
        root->right = right;
        return root;
    }
};
```



**时间复杂度：** **O(n)** 

**空间复杂度：** **O(n) **



#### 从根节点到叶节点的路径数字之和

**来源：**	https://leetcode.cn/problems/3Etpl5/

**想法：**

​	遍历树即可

```java
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int sum = 0;
    void run(TreeNode* node, int val) {
        if (node->left != nullptr) run(node->left,val * 10 + node->val);
        if (node->right != nullptr) run(node->right,val * 10 + node->val);
        if (node->left == nullptr && node->right == nullptr) sum += val * 10 + node->val;
    }
    int sumNumbers(TreeNode* root) {
        run(root,0);
        return sum;
    }
};
```



**时间复杂度：** **O(n)** 

**空间复杂度：** **O(n) **





#### 向下的路径节点之和

**来源：**	https://leetcode.cn/problems/6eUYwP/

**想法：**

​	遍历树的同时维护节点路径

```java
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int res = 0;
    int target;
    void preorder(TreeNode* node, vector<int>& road) {
        road.push_back(node->val);
        if (node->left != nullptr) preorder(node->left,road);
        if (node->right != nullptr) preorder(node->right,road);
        int tmp = 0;
        for (int i = road.size() - 1 ; i >= 0 ; i--) {
            tmp += road[i];
            if (tmp == target) {
                res++;
            }
        }
        road.pop_back();
    }
    int pathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) return 0;
        vector<int> v;
        target = targetSum;
        preorder(root,v);
        return res;
    }
};
```



**时间复杂度：** **O(n²)** 

**空间复杂度：** **O(n) **





#### 展平二叉搜索树

**来源：**	https://leetcode.cn/problems/NYBBNL/

**想法：**

​	前序遍历

```java
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode *res = nullptr;
    TreeNode *head;
    void midorder(TreeNode *node) {
        if (node->left != nullptr) midorder(node->left);
        if (res == nullptr) {
            res = new TreeNode(node->val);
            head = res;
        }
        else {
            res->right = new TreeNode(node->val);
            res = res->right;
        }
        if (node->right != nullptr) midorder(node->right);
    }
    TreeNode* increasingBST(TreeNode* root) {
        midorder(root);
        return head;
    }
};
```



**时间复杂度：** **O(n²)** 

**空间复杂度：** **O(n) **



#### 二叉搜索树中的中序后继

**来源：**	https://leetcode.cn/problems/P5rCT8/

**想法：**

​	中序遍历

```java
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
        stack<TreeNode*> s;
        bool sign = false;
        while (root != nullptr || !s.empty()) {
            while (root != nullptr) {
                s.push(root);
                root = root->left;
            }
            root = s.top();
            s.pop();
            if (sign) break;
            if (root == p) sign = true;
            root = root->right;
        }
        return root;
    }
};
```



**时间复杂度：** **O(n)** 

**空间复杂度：** **O(n) **



#### 所有大于等于节点的值之和

**来源：**	https://leetcode.cn/problems/w6cpku/

**想法：**

​	中序遍历

```java
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* convertBST(TreeNode* root) {
        TreeNode *tmp1 = root, *tmp2 = root;
        stack<TreeNode*> s;
        int sum = 0;
        int prev = 0;
        while (tmp1 != nullptr || !s.empty()) {
            while (tmp1 != nullptr) {
                s.push(tmp1);
                tmp1 = tmp1->left;
            }
            tmp1 = s.top();
            s.pop();
            sum += tmp1->val;
            tmp1 = tmp1->right;
        }
        while (tmp2 != nullptr || !s.empty()) {
            while (tmp2 != nullptr) {
                s.push(tmp2);
                tmp2 = tmp2->left;
            }
            tmp2 = s.top();
            s.pop();
            int tmp = tmp2->val;
            tmp2->val = sum - prev;
            prev += tmp;
            tmp2 = tmp2->right;
        }
        return root;
    }
};
```



**时间复杂度：** **O(n)** 

**空间复杂度：** **O(n) **





#### 二叉搜索树中两个节点之和

**来源：**	https://leetcode.cn/problems/opLdQZ/

**想法：**

​	中序遍历,用哈希表存储已经遍历到的节点的值，然后每遍历一个节点，只需要找哈希表里是否存在 k - val 即可

```java
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool findTarget(TreeNode* root, int k) {
        stack<TreeNode*> s;
        set<int> base;
        while (root != nullptr || !s.empty()) {
            while (root != nullptr) {
                s.push(root);
                root = root->left;
            }
            root = s.top();
            s.pop();
            if (base.find(k - root->val) != base.end()) return true;
            base.insert(root->val);
            root = root->right;
        }
        return false;
    }
};
```



**时间复杂度：** **O(n)** 

**空间复杂度：** **O(n) **





#### 日程表

**来源：**	https://leetcode.cn/problems/opLdQZ/

**想法：**

​	线段树，left存储日程在节点之前的，right存储日程在节点之后的

```java
class MyCalendar {
public:
    struct TreeNode{
        TreeNode* left;
        TreeNode* right;
        int start;
        int end;
        TreeNode(int x, int y) : start(x), end(y), left(nullptr), right(nullptr) {}
    };
    TreeNode *root = nullptr;
    MyCalendar() {

    }
    
    bool book(int start, int end) {
        if (root == nullptr) {
            root = new TreeNode(start,end);
            return true;
        }
        TreeNode *tmp = root;
        while (tmp != nullptr) {
            if (end <= tmp->start) {
                if (tmp->left == nullptr) {
                    tmp->left = new TreeNode(start,end);
                    return true;
                }
                tmp = tmp->left;
            }else if (start >= tmp->end){
                if (tmp->right == nullptr) {
                    tmp->right = new TreeNode(start,end);
                    return true;
                }
                tmp = tmp->right;
            }else return false;
        }
        return true;
    }
};
```



**时间复杂度：** **O(logn)** 

**空间复杂度：** **O(n) **
