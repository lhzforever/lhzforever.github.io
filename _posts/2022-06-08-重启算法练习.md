---
layout: article
title: 算法练习
tags: 算法
show_subscribe: false
show_edit_on_github: false
license: false
---

<!--more-->

## 算法苦手




### 整数除法

**来源：**	https://leetcode.cn/problems/xoh6Oh/

**想法：**

​	每次通过位运算获得当前比a最小的b的最大倍数，然后记录该倍数，再让a与b相减，重复该过程即可。

```java
class Solution {
public:
    int divide(int a, int b) {
        int sign = a > 0 ^ b > 0 ? -1 : 1;
        int res = 0;
        if (a == -1 * pow(2,31) && b == -1) return pow(2,31) - 1;
        else {
           a = a > 0 ? -a : a;
            b = b > 0 ? -b : b;
            while (a <= b) {
                bool flag = false;
                if (a == b) {
                    res++;
                    break;
                }
                int temp1 = a, temp2 = b, temp3 = 0;
                while (temp1 < temp2 && temp2 >= -1 * pow(2,30)) {
                    flag = true;
                    temp2 *= 2;
                    temp3 = temp3 == 0 ? 1 : temp3 << 1;
                }
                if (flag) {
                    if (temp2 != temp1) temp2 /= 2; 
                    else temp3 <<= 1;
                } else {
                    temp3 = 1;
                }
                res += temp3;
                a -= temp2;
            }
        }
        if (res == -1 * pow(2,31)) return res;
        return abs(res) * sign;
    }
};
```

**时间复杂度：** **O(n)**

**空间复杂度：** **O(1)**

**优化：**

​	写法有待优化







### 前 n 个数字二进制中 1 的个数

**来源：**	https://leetcode.cn/problems/w3tCBm/

**想法：**

​	以当前索引为2的幂次为一次轮换，每次轮换都从vector的头开始计算，结果加1

```java
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> res;
        res.push_back(0);
        if (n == 0) return res;
        res.push_back(1);
        if (n == 1) return res;
        int j;
        for (int i = 2 ; i <= n; i++) {
            if ((i & (i - 1)) == 0) {
                j = 0;
            }
            res.push_back(res[j++] + 1);
        }
        return res;
    }
};
```

**时间复杂度：** **O(n)**

**空间复杂度：** **O(n)**





### 二进制加法

**来源：**	https://leetcode.cn/problems/xoh6Oh/

**想法：**

​	实现二进制加法

```java
class Solution {
public:
    string addBinary(string a, string b) {
        string res;
        int l1 = a.length(), l2 = b.length();
        int sign = 0;
        for (int i = l1 - 1 ,j = l2 - 1; i >= 0 || j >= 0; i--,j--) {
            int tmp;
            if (i >= 0 && j >= 0) tmp = a[i] - '0' + b[j] - '0' + sign;
            else if (i >= 0) tmp = a[i] - '0' + sign;
            else tmp = b[j] - '0' + sign;
            if (tmp == 0) {
                res += "0";
                sign = 0;
            }
            else if (tmp == 1) {
                res += "1";
                sign = 0;
            }
            else if (tmp == 2) {
                res += "0";
                sign = 1;
            }
            else {
                res += "1";
                sign = 1;
            }
        }
        if (sign == 1) res += "1";
        std::reverse(res.begin(), res.end());
        return res;
    }
};
```







