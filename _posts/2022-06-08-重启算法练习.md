---
layout: article
title: 算法练习
tags: 算法
show_subscribe: false
show_edit_on_github: false
license: false
---

<!--more-->

## 算法苦手




### 整数除法

**来源：**	https://leetcode.cn/problems/xoh6Oh/

**想法：**

​	每次通过位运算获得当前比a最小的b的最大倍数，然后记录该倍数，再让a与b相减，重复该过程即可。

```java
class Solution {
public:
    int divide(int a, int b) {
        int sign = a > 0 ^ b > 0 ? -1 : 1;
        int res = 0;
        if (a == -1 * pow(2,31) && b == -1) return pow(2,31) - 1;
        else {
           a = a > 0 ? -a : a;
            b = b > 0 ? -b : b;
            while (a <= b) {
                bool flag = false;
                if (a == b) {
                    res++;
                    break;
                }
                int temp1 = a, temp2 = b, temp3 = 0;
                while (temp1 < temp2 && temp2 >= -1 * pow(2,30)) {
                    flag = true;
                    temp2 *= 2;
                    temp3 = temp3 == 0 ? 1 : temp3 << 1;
                }
                if (flag) {
                    if (temp2 != temp1) temp2 /= 2; 
                    else temp3 <<= 1;
                } else {
                    temp3 = 1;
                }
                res += temp3;
                a -= temp2;
            }
        }
        if (res == -1 * pow(2,31)) return res;
        return abs(res) * sign;
    }
};
```

**时间复杂度：** **O(n)**

**空间复杂度：** **O(1)**

**优化：**

​	写法有待优化







### 前 n 个数字二进制中 1 的个数

**来源：**	https://leetcode.cn/problems/w3tCBm/

**想法：**

​	以当前索引为2的幂次为一次轮换，每次轮换都从vector的头开始计算，结果加1

```java
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> res;
        res.push_back(0);
        if (n == 0) return res;
        res.push_back(1);
        if (n == 1) return res;
        int j;
        for (int i = 2 ; i <= n; i++) {
            if ((i & (i - 1)) == 0) {
                j = 0;
            }
            res.push_back(res[j++] + 1);
        }
        return res;
    }
};
```

**时间复杂度：** **O(n)**

**空间复杂度：** **O(n)**





### 二进制加法

**来源：**	https://leetcode.cn/problems/xoh6Oh/

**想法：**

​	实现二进制加法

```java
class Solution {
public:
    string addBinary(string a, string b) {
        string res;
        int l1 = a.length(), l2 = b.length();
        int sign = 0;
        for (int i = l1 - 1 ,j = l2 - 1; i >= 0 || j >= 0; i--,j--) {
            int tmp;
            if (i >= 0 && j >= 0) tmp = a[i] - '0' + b[j] - '0' + sign;
            else if (i >= 0) tmp = a[i] - '0' + sign;
            else tmp = b[j] - '0' + sign;
            if (tmp == 0) {
                res += "0";
                sign = 0;
            }
            else if (tmp == 1) {
                res += "1";
                sign = 0;
            }
            else if (tmp == 2) {
                res += "0";
                sign = 1;
            }
            else {
                res += "1";
                sign = 1;
            }
        }
        if (sign == 1) res += "1";
        std::reverse(res.begin(), res.end());
        return res;
    }
};
```





### 只出现一次的数字

**来源：**	https://leetcode.cn/problems/WGki4K/

**想法：**

​	本人的想法就是使用hashset，看完了题解中他人的想法后，改进为O(1)的空间复杂度。

​	想法即为：出现三次的元素每一位相加得到的结果都为3的倍数，只要将数组中每一个元素每一位分别相加的到的结果模3，即得到了仅出现一次的那个元素的那一位。

```java
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        for (int i = 0; i < 32; ++i) {
            int total = 0;
            for (int num: nums) {
                total += ((num >> i) & 1);
            }
            if (total % 3) {
                ans |= (1 << i);
            }
        }
        return ans;
    }
};
```

**时间复杂度：** **O(nlgC)** **C为数字位数长度**

**空间复杂度：** **O(1)**





### 单词长度的最大乘积

**来源：**	https://leetcode.cn/problems/aseY1I/

**想法：**

​	将字符串映射为一个26位的数，这样判断字符串是否有相同字符时，就只需要判断与的结果是否为0即可

```java
class Solution {
public:
    int maxProduct(vector<string>& words) {
        vector<int> masks(words.size());
        int res = 0;
        for (int i = 0 ; i < words.size(); i++) {
            for (char c : words[i]) {
                masks[i] |= 1 << (c - 'a');
            }
        }
        for (int i = 0 ; i < words.size(); i++) {
            for (int j = i + 1 ; j < words.size(); j++) {
                if ((masks[i] & masks[j]) == 0) {
                    res = max(res,(int)(words[i].length() * words[j].length()));
                }
            }
        }
        return res;
    }
};
```



**时间复杂度：** **O(L + n²)** **C为数字位数长度** **L为数组中所有单词长度之和**

**空间复杂度：** **O(n)**





### 排序数组中两个数字之和

**来源：**	https://leetcode.cn/problems/kLl5u1/

**想法：**

​	固定一个数，在另一边找另一个数是否满足要求。

```java
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        vector<int> res(2);
        bool flag = false;
        for (int i = 0 ; i < numbers.size() % 2 == 0 ? numbers.size() / 2 : numbers.size() / 2 + 1; i++) {
            for (int j = numbers.size() - 1 ; j >= 0 ; j--) {
                if (target == numbers[i] + numbers[j]) {
                    flag = true;
                    res[0] = i;
                    res[1] = j;
                    break;
                }
                if (target > numbers[i] + numbers[j]) break;
            }
            if (flag) break;
        }
        return res;
    }
};
```



**时间复杂度：** **O(n²)** 

**空间复杂度：** **O(1)**
