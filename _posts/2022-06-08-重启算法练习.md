---
layout: article
title: 算法练习
tags: 算法
show_subscribe: false
show_edit_on_github: false
license: false
---

<!--more-->

## 算法苦手




### 整数除法

**来源：**	https://leetcode.cn/problems/xoh6Oh/

**想法：**

​	每次通过位运算获得当前比a最小的b的最大倍数，然后记录该倍数，再让a与b相减，重复该过程即可。

```java
class Solution {
public:
    int divide(int a, int b) {
        int sign = a > 0 ^ b > 0 ? -1 : 1;
        int res = 0;
        if (a == -1 * pow(2,31) && b == -1) return pow(2,31) - 1;
        else {
           a = a > 0 ? -a : a;
            b = b > 0 ? -b : b;
            while (a <= b) {
                bool flag = false;
                if (a == b) {
                    res++;
                    break;
                }
                int temp1 = a, temp2 = b, temp3 = 0;
                while (temp1 < temp2 && temp2 >= -1 * pow(2,30)) {
                    flag = true;
                    temp2 *= 2;
                    temp3 = temp3 == 0 ? 1 : temp3 << 1;
                }
                if (flag) {
                    if (temp2 != temp1) temp2 /= 2; 
                    else temp3 <<= 1;
                } else {
                    temp3 = 1;
                }
                res += temp3;
                a -= temp2;
            }
        }
        if (res == -1 * pow(2,31)) return res;
        return abs(res) * sign;
    }
};
```

**时间复杂度：** **O(n)**

**空间复杂度：** **O(1)**

**优化：**

​	写法有待优化







### 前 n 个数字二进制中 1 的个数

**来源：**	https://leetcode.cn/problems/w3tCBm/

**想法：**

​	以当前索引为2的幂次为一次轮换，每次轮换都从vector的头开始计算，结果加1

```java
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> res;
        res.push_back(0);
        if (n == 0) return res;
        res.push_back(1);
        if (n == 1) return res;
        int j;
        for (int i = 2 ; i <= n; i++) {
            if ((i & (i - 1)) == 0) {
                j = 0;
            }
            res.push_back(res[j++] + 1);
        }
        return res;
    }
};
```

**时间复杂度：** **O(n)**

**空间复杂度：** **O(n)**





### 二进制加法

**来源：**	https://leetcode.cn/problems/xoh6Oh/

**想法：**

​	实现二进制加法

```java
class Solution {
public:
    string addBinary(string a, string b) {
        string res;
        int l1 = a.length(), l2 = b.length();
        int sign = 0;
        for (int i = l1 - 1 ,j = l2 - 1; i >= 0 || j >= 0; i--,j--) {
            int tmp;
            if (i >= 0 && j >= 0) tmp = a[i] - '0' + b[j] - '0' + sign;
            else if (i >= 0) tmp = a[i] - '0' + sign;
            else tmp = b[j] - '0' + sign;
            if (tmp == 0) {
                res += "0";
                sign = 0;
            }
            else if (tmp == 1) {
                res += "1";
                sign = 0;
            }
            else if (tmp == 2) {
                res += "0";
                sign = 1;
            }
            else {
                res += "1";
                sign = 1;
            }
        }
        if (sign == 1) res += "1";
        std::reverse(res.begin(), res.end());
        return res;
    }
};
```





### 只出现一次的数字

**来源：**	https://leetcode.cn/problems/WGki4K/

**想法：**

​	本人的想法就是使用hashset，看完了题解中他人的想法后，改进为O(1)的空间复杂度。

​	想法即为：出现三次的元素每一位相加得到的结果都为3的倍数，只要将数组中每一个元素每一位分别相加的到的结果模3，即得到了仅出现一次的那个元素的那一位。

```java
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        for (int i = 0; i < 32; ++i) {
            int total = 0;
            for (int num: nums) {
                total += ((num >> i) & 1);
            }
            if (total % 3) {
                ans |= (1 << i);
            }
        }
        return ans;
    }
};
```

**时间复杂度：** **O(nlgC)** **C为数字位数长度**

**空间复杂度：** **O(1)**





### 单词长度的最大乘积

**来源：**	https://leetcode.cn/problems/aseY1I/

**想法：**

​	将字符串映射为一个26位的数，这样判断字符串是否有相同字符时，就只需要判断与的结果是否为0即可

```java
class Solution {
public:
    int maxProduct(vector<string>& words) {
        vector<int> masks(words.size());
        int res = 0;
        for (int i = 0 ; i < words.size(); i++) {
            for (char c : words[i]) {
                masks[i] |= 1 << (c - 'a');
            }
        }
        for (int i = 0 ; i < words.size(); i++) {
            for (int j = i + 1 ; j < words.size(); j++) {
                if ((masks[i] & masks[j]) == 0) {
                    res = max(res,(int)(words[i].length() * words[j].length()));
                }
            }
        }
        return res;
    }
};
```



**时间复杂度：** **O(L + n²)** **C为数字位数长度** **L为数组中所有单词长度之和**

**空间复杂度：** **O(n)**





### 排序数组中两个数字之和

**来源：**	https://leetcode.cn/problems/kLl5u1/

**想法：**

​	固定一个数，在另一边找另一个数是否满足要求。

```java
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        vector<int> res(2);
        bool flag = false;
        for (int i = 0 ; i < numbers.size() % 2 == 0 ? numbers.size() / 2 : numbers.size() / 2 + 1; i++) {
            for (int j = numbers.size() - 1 ; j >= 0 ; j--) {
                if (target == numbers[i] + numbers[j]) {
                    flag = true;
                    res[0] = i;
                    res[1] = j;
                    break;
                }
                if (target > numbers[i] + numbers[j]) break;
            }
            if (flag) break;
        }
        return res;
    }
};
```



**时间复杂度：** **O(n²)** 

**空间复杂度：** **O(1)**





### 数组中和为0的三个数

**来源：**	https://leetcode.cn/problems/1fGaJU/

**想法：**

​	先通过排序，确保找到的三个数不会因为遍历而造成重复。

​	然后固定第一个数，使用双指针从第一个数右边开始遍历，如果三个数之和结果大于0，就将右指针左移，如果三个数之和小于0，就将左指针右移，同时在找到满足的结果时，要保证下一次遍历的开始的数与上一次的结果不同。

```java
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        vector<vector<int>> ans;
        for (int first = 0; first < n; ++first) {
            if (first > 0 && nums[first] == nums[first - 1]) {
                continue;
            }
            int third = n - 1;
            int target = -nums[first];
            for (int second = first + 1; second < n; ++second) {
                if (second > first + 1 && nums[second] == nums[second - 1]) {
                    continue;
                }
                while (second < third && nums[second] + nums[third] > target) {
                    --third;
                }
                if (second == third) {
                    break;
                }
                if (nums[second] + nums[third] == target) {
                    ans.push_back({nums[first], nums[second], nums[third]});
                }
            }
        }
        return ans;
    }
};
```



**时间复杂度：** **O(n²)** 

**空间复杂度：** **O(n)**





### 和大于等于target的最短子数组

**来源：**	https://leetcode.cn/problems/2VG8Kg/

**想法：**

​	滑动窗口实现

```java
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int ans = INT_MAX;
        int start = 0, end = 0;
        int sum = 0;
        while (end < n) {
            sum += nums[end];
            while (sum >= target) {
                ans = min(ans, end - start + 1);
                sum -= nums[start];
                start++;
            }
            end++;
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```



**时间复杂度：** **O(n)** 

**空间复杂度：** **O(1)**





### 乘积小于k的子数组

**来源：**	https://leetcode.cn/problems/ZVAVXX/

**想法：**

​	滑动窗口实现

```java
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        int len = nums.size();
        int ans = 0 ;
        int sum = 1 ;
        int l=0, r=0;
        while(r<len){
            sum = sum * nums[r];
            while(sum>=k&&l<=r){
                sum/=nums[l++];
            }
            ans = ans + r-l+1;
            r++;
        }
        return ans;
    }
};
```



**时间复杂度：** **O(n)** 

**空间复杂度：** **O(1)**



### 字符串中的变位词

**来源：**	https://leetcode.cn/problems/MPnaiL/

**想法：**

​	滑动窗口实现，通过diff变量记录窗口中s2的子串与s1的字符数量差距，通过cnt数组记录差值，移动窗口时，如果插值从0变为正负1时，diff++，如果插值变为0时，diff--。

```java
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        bool ans = false;
        if (s1.length() > s2.length() ) return false;
        int cnt[26] = {0};
        for (char c : s1){
            cnt[c - 'a']++;
        }
        for (int i = 0 ; i < s1.length(); i++) {
            cnt[s2[i] - 'a']--;
        }
        int diff = 0;
        for (int i : cnt) {
            if (i != 0) diff++;
        }
        for (int l = 0, r = s1.length(); r < s2.length();l++,r++) {
            if (diff == 0) {
                ans = true;
                break;
            }else {
                int sign1 = cnt[s2[l] - 'a'];
                cnt[s2[l] - 'a']++;
                if (cnt[s2[l] - 'a'] == 0) diff--;
                else if (sign1 == 0)diff++;
                int sign2 = cnt[s2[r] - 'a'];
                cnt[s2[r] - 'a']--;
                if (cnt[s2[r] - 'a'] == 0) diff--;
                else if (sign2 == 0)diff++;
            }
        }
        if (diff == 0) return true;
        return ans;
    }
};
```



**时间复杂度：** **O(n + m + C)** ,C为字符集大小

**空间复杂度：** **O(C)**， C为字符集大小





### 字符串中的所有变位词

**来源：**	https://leetcode.cn/problems/VabMRr/

**想法：**

​	与上题一致。

```java
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> ans;
        if (s.length() < p.length()) return ans;
        int cnt[26] = {0};
        for (char c : p){
            cnt[c - 'a']++;
        }
        for (int i = 0 ; i < p.length(); i++) {
            cnt[s[i] - 'a']--;
        }
        int diff = 0;
        for (int i : cnt) {
            if (i != 0) diff++;
        }
        for (int l = 0, r = p.length(); r < s.length();l++,r++) {
            if (diff == 0) {
            	ans.push_back(l);
            }
            int sign1 = cnt[s[l] - 'a'];
            cnt[s[l] - 'a']++;
            if (cnt[s[l] - 'a'] == 0) diff--;
            else if (sign1 == 0)diff++;
            int sign2 = cnt[s[r] - 'a'];
            cnt[s[r] - 'a']--;
            if (cnt[s[r] - 'a'] == 0) diff--;
            else if (sign2 == 0)diff++;
            }
        if (diff == 0)  ans.push_back(s.length() - p.length());
        return ans;
    }
};
```



**时间复杂度：** **O(n + m + C)** ,C为字符集大小

**空间复杂度：** **O(C)**， C为字符集大小





### 不含重复字符的最长子字符串

**来源：**	https://leetcode.cn/problems/wtcaE1/

**想法：**

​	使用滑动窗口，滑动时先判断：

​	右窗口是否与其左边字符相同，如果相同则一直向右移动直到不相同，然后左窗口移动到右窗口的左边

​	如果不与其左边字符相同，则根据记录的字符数量数组判断：

​		如果当前右窗口的字符数大于1，则将左窗口一直移动到与右窗口字符相同的位置的右边一位

​		如果不大于1，则计算窗口大小，与ans取max

```java
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.length();
        if (n == 0) return 0;
        int ans = 1;
        int cnt[128] = {0};
        int l = 0,r = 1;
        cnt[s[0]]++;
        while (r < n) {
            cnt[s[r]]++;
            if (s[r] == s[r - 1]) {
                while(r < n && s[r] == s[r - 1]) {
                    r++;
                    cnt[s[r]]++;
                }
                cnt[s[r]]--;
                while (l < r - 1) {
                    cnt[s[l]]--;
                    l++;
                }
            }else {
                if (cnt[s[r]] > 1) {
                    while (s[l] != s[r]) {
                        cnt[s[l]]--;
                        l++;
                    }
                    cnt[s[l]]--;
                    l++;
                }else ans = max(ans,r - l + 1);
                r++;
            }
        }
        return ans;
    }
};
```



**时间复杂度：** **O(n)** 

**空间复杂度：** **O(C)**， C为字符集大小





### 有效的回文

**来源：**	https://leetcode.cn/problems/XltzEq/

**想法：**

​	双指针实现。

```java
class Solution {
public:
    bool isPalindrome(string s) {
        int n = (int)s.length();
        if (n == 0) return true;
        bool ans = true;
        int l = 0, r = n - 1;
        while (l < r) {
            while (l < n && !isalnum(s[l])) l++;
            while (r > 0 && !isalnum(s[r])) r--;
            if (l == n && r == 0) break;
            if (tolower(s[l]) != tolower(s[r])) {
                ans = false;
                break;
            }
            l++,r--;
        }
        return ans;
    }
};
```



**时间复杂度：** **O(n)** 

**空间复杂度：** **O(1)**





### 最多删除一个字符得到回文

**来源：**	https://leetcode.cn/problems/RQku0D/

**想法：**

​	贪心+双指针，如果左右指针的字符不同时，判断删除最左边字符或者删除最右边字符，如果有一种满足回文，则成立。

```java
class Solution {
public:
    bool validPalindrome(string s) {
        int n = s.length();
        int l = 0, r = n - 1;
        bool sign = false;
        while (l < r) {
            if (s[l] != s[r]) {
                sign = true;
                break;
            }
            l++,r--;
        }
        if (!sign) return true;
        if (l == r - 1) return true;
        else {
            int l1 = l, r1 = r - 1, l2 = l + 1, r2 = r;
            bool flag1 = true, flag2 = true;
            while (l1 < r1) {
                if (s[l1] != s[r1]) {
                    flag1 = false;
                    break;
                }
                l1++,r1--;
            }
            while (l2 < r2) {
                if (s[l2] != s[r2]) {
                    flag2 = false;
                    break;
                }
                l2++,r2--;
            }
            return flag1 || flag2;
        }
    }
};
```



**时间复杂度：** **O(n)** 

**空间复杂度：** **O(1)**





### 回文子字符串的个数

**来源：**	https://leetcode.cn/problems/a7VOhD/

**想法：**

​	枚举回文子串的中心，然后使用双指针向两边拓展。

```java
class Solution {
public:
    int countSubstrings(string s) {
        int n = s.size(), ans = 0;
        for (int i = 0; i < 2 * n - 1; ++i) {
            int l = i / 2, r = i / 2 + i % 2;
            while (l >= 0 && r < n && s[l] == s[r]) {
                --l;
                ++r;
                ++ans;
            }
        }
        return ans;
    }
};
```



**时间复杂度：** **O(n²)** 

**空间复杂度：** **O(1)**





### 删除链表的倒数第n个结点

**来源：**	https://leetcode.cn/problems/SLwz0R/

**想法：**

​	双指针，保持间距为n即可

```java
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* res = head;
        ListNode* first = head;
        ListNode* second = head;

        for (int i  = 0 ; i < n ; i++) {
            first = first->next;
        }
        if (first == nullptr) return head->next;
        while (first->next != nullptr) {
            first = first->next;
            second = second->next;
        }
        second->next = second->next->next;
        return res;
    }
};
```



**时间复杂度：** **O(n)** 

**空间复杂度：** **O(1)**





### 链表中环的入口节点

**来源：**	https://leetcode.cn/problems/c32eOV/

**想法：**

​	双指针，一个指针以1为步长移动，一个指针以2为步长移动，如果两个指针能够相遇，那么就存在环

```java
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *slow = head, *fast = head;
        while (fast != nullptr) {
            slow = slow->next;
            if (fast->next == nullptr) {
                return nullptr;
            }
            fast = fast->next->next;
            if (fast == slow) {
                ListNode *ptr = head;
                while (ptr != slow) {
                    ptr = ptr->next;
                    slow = slow->next;
                }
                return ptr;
            }
        }
        return nullptr;
    }
};
```



**时间复杂度：** **O(n)** 

**空间复杂度：** **O(1)**





### 两个链表的第一个重合节点

**来源：**	https://leetcode.cn/problems/3u1WK4/

**想法：**

​	双指针，一个指针从链表一开始，遍历完后从链表二开始，另一个相反，输出它们相遇时的节点即可。

```java
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if (headA == nullptr || headB == nullptr) {
            return nullptr;
        }
        ListNode *pA = headA, *pB = headB;
        while (pA != pB) {
            pA = pA == nullptr ? headB : pA->next;
            pB = pB == nullptr ? headA : pB->next;
        }
        return pA;
    }
};
```



**时间复杂度：** **O(n)** 

**空间复杂度：** **O(1)**







### 反转链表

**来源：**	https://leetcode.cn/problems/UHnkqh/

**想法：**

​	反转链表

```java
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) return head;
        if (head->next->next == nullptr) {
            ListNode *res = head->next;
            head->next->next = head;
            head->next = nullptr;
            return res;
        }
        ListNode *p1 = head, *p2 = head->next, *p3 = head->next->next;
        head->next = nullptr;
        while (p3 != nullptr) {
            p2->next = p1;
            p1 = p2;
            p2 = p3;
            p3 = p3->next;
        }
        p2->next = p1;
        return p2;
    }
};
```



**时间复杂度：** **O(n)** 

**空间复杂度：** **O(1)**





### 链表中的两数相加

**来源：**	https://leetcode.cn/problems/lMSNwu/

**想法：**

​	使用栈实现逆序

```java
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        stack<int> s1, s2;
        while (l1) {
            s1.push(l1 -> val);
            l1 = l1 -> next;
        }
        while (l2) {
            s2.push(l2 -> val);
            l2 = l2 -> next;
        }
        int carry = 0;
        ListNode* ans = nullptr;
        while (!s1.empty() or !s2.empty() or carry != 0) {
            int a = s1.empty() ? 0 : s1.top();
            int b = s2.empty() ? 0 : s2.top();
            if (!s1.empty()) s1.pop();
            if (!s2.empty()) s2.pop();
            int cur = a + b + carry;
            carry = cur / 10;
            cur %= 10;
            auto curnode = new ListNode(cur);
            curnode -> next = ans;
            ans = curnode;
        }
        return ans;
    }
};
```



**时间复杂度：** **O(n)** 

**空间复杂度：** **O(1)**
