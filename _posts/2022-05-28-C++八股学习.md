---
layout: article
title: C++整理
tags: C++
show_subscribe: false
show_edit_on_github: false
license: false

---

<!--more-->

## 智能指针

### 为什么要使用智能指针？

​	为了使指针在生命周期结束时，不仅仅释放存放指针的内存，也释放其指向的内存，防止内存泄漏。因此将其包装为一个对象，这样在生命周期结束时就可以通过调用析构函数来释放内存。

### 智能指针的四种方案

#### auto_ptr

​	**auto_ptr** 采取所有权的形式来实现，但 **C++11** 已经抛弃，原因在于如果出现以下情况：

```c++
auto_ptr<string> p1 = (new string("hello"));
auto_ptr<string> p2;
p2 = p1;
```

​	此时如果再次调用p1就会产生访问空指针的错误，但在编译阶段并不会报错，所以 **C++11** 采取了替代措施。

#### unique_ptr

​	**unique_str** 保证了同一时间只有一个智能指针可以指向该对象，如果出现如下情况：

```c++
unique_ptr<string> p1 = (new string("hello"));
unique_ptr<string> p2;
p2 = p1;
```

​	此时在编译阶段就会报错，因为 **unique_ptr** 不允许这样的操作。

#### **shared_ptr**

​	**shared_ptr** 则采取计数机制来记录当前有多少个智能指针指向该对象，直到最后一个智能指针被释放时，才会释放分配了的空间。

#### weak_ptr

​	**weak_ptr** 并不控制对象的生命周期，它指向一个 **shared_ptr** 管理的对象，它主要用于配合 **shared_ptr** ，解决两个 **shared_ptr** 互相引用时的死锁。





## C++内存模型

​	C++内存分区主要分为堆、栈、代码区、全局区、常量区。

### 代码区

* 代码区存放程序的二进制代码供CPU执行
* 代码区是共享的
* 代码区是只读的

### 全局区

​	全局区分为已初始化和未初始化两个区域，存放全局变量和静态变量。

### 堆

​	堆由程序员进行内存维护和释放，通过使用 **malloc/free** 和 **new/delete** 来申请和销毁内存所在的区域。

​	堆由低地址向高地址延申。

### 栈

​	栈由编译器自动分配释放，存放函数的参数值、局部变量、形参等。

​	函数栈入参顺序：

​		函数局部变量 $\rarr$ 最右参数 $\rarr$ 中间参数 $\rarr$ 最左参数 $\rarr$ 返回地址 $\rarr$ 运行时参数

### 常量区

​	存放常量的区间，一旦初始化后就不能修改。







## C++参数传递

### 值传递

​	按值传递时，被调函数会创建一个实参的副本来存放传递进来的值，因此在被调函数中做的任何操作都不会对主调函数传递进来的实参有作用。

### 指针传递

​	地址传递的本质也是传值，只是它所传递的是指针指向的地址，被调函数同样也会创建一个同样类型的指针副本指向同一个地址，由于现在的操作是通过寻址进行的，所以在被调函数中任何对于存放在该地址的变量的操作都会影响到主调函数传递进来的实参。

### 引用传递

​	引用传递传递的是变量本身的地址，同样在被调函数中的操作会影响到主调函数传递进来的实参。

### 指针传递与引用传递的不同

​	指针传递本质仍是值传递，它对于形参的操作都不会反映于实参；引用传递是地址传递，它对于形参的操作都会通过间接寻址的方式操作到实参上。









## const

